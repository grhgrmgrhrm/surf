**Вопрос:** Как предотвратить лишние рендеры у функциональных компонентов

**Ответ:** 

Компоненты имеют состояние, и когда под действиями пользователя эти состояния изменятется, то требуется перерисовка компонента. Компонент React может перерисовыватьстя сколь угодно раз. Но очень часто в этом нет необходимости и можно обойтись без перерисовки, так как это очень влияет на производительность приложения. В React, после повторного рендеринга родителя также происходит рендеринг дочерних компонентов, что сильно влияет на производительность.

Избежать лишнего рендера в классовых компонентах в основном используетя React.PureComponent либо метод жизненного цикла shouldComponentUpdate

***React.memo()***

В функциональных компонентах используются React.memo() - принцип работы схож с принципом работы React.PureComponent. Если функциональный компонент обёрнут в React.memo, он будет повторно рендериться при изменении состояния или контекста.

***useEffect***

Также можно использовать useEffect - он включает в себя аналоги классических хуков componentDidMount, componentDidUpdate и componentWillUnmount. Для того, чтобы не было лишних отрисовок нужно понимать в каком случае срабатывает componentDidMount и в каком и как - componentDidUpdate. 
В случае если второй аргумент, (который является массивом значений) отсутствует, useEffect будет срабатывать при каждом рендеринге. Если второй аргумент будет передан, то ререндер будет вызван только при изменении значений массива. 
Если же вторым агрументом передать пустой массив [], то будет считаться, что у useEffect нет зависимостей и он выполнится разово. Это аналог componentDidMount.

***useCallback*** 

useCallback возвращает мемоизированную версию функции. Данный хук запоминает версию обратного вызова, для избежания повторных рендерингов дочерних элементов. Яркий пример - повесить на кнопку счетчик, при нажатии на которую будет отображаться текст с числом нажатий. Если обработчик кнопки не обернуть в useCallback, то компонент будет перерендеваться каждый раз.

***useMemo***

useMemo - запоминает результат выполнения функции между рендерами, избегает повторных дорогостоящих вычислений, при неизменных переменных.

Первым параметром задается функция которая будет мемоизироваться, вторым - массив зависимостей.

В случае изменения одной зависимостей функция будет пересчитана.

